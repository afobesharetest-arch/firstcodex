# Hex-патч для обхода проверки `getIsLiveServer` в окне системных сообщений

Ниже — полный контекст байткода из `1.txt` (строки 153–178) вокруг проверки `getIsLiveServer`, чтобы в HxD было легко найти нужный участок даже без офсетов (смещения дублируются в скобках справа от точки с запятой в `1.txt`):

```
1B 57 3D 16 16 07 D7 01 19 1B 12 16 06 00 04 1B 39 16 1C E9 02 1F 67 6C 6F 62 61 6C 00 1F 53 79 73 74 65 6D 4D 73 67 57 6E 64 00
```

* **Искомая подпоследовательность (ровно как в `1.txt`):** `07 D7 01 19 1B 12 16 06 00 04 1B 39 16`
* **Рабочая замена для включения окна:** `00 00 00 19 1B 12 16 06 00 04 1B 39 16`

Алгоритм поиска в HxD:
1. Открой бинарник и выбери поиск по HEX.
2. Вставь длинный контекст из блока выше — он уникально встречается в файле (второй раз только в сводке расшифровки ниже), поэтому подсветит правильное место между вызовами `SaveChatFilterOption()` и `GetINIBool("SystemMsgWnd")`.
3. Убедись, что байты на позициях `... 16 16 07 D7 01 ... 39 16 1C ...` совпадают, и обнули первые три байта (`07 D7 01` → `00 00 00`), чтобы вообще убрать условный переход. Смещение остаётся на месте, длина секции не меняется, и выполнение больше не уходит к `J0x1D7`.

Эта правка полностью удаляет переход из блока проверки `getIsLiveServer()`: после NOP'а (`00 00 00`) код линейно идёт к загрузке `SystemMsgWnd` из INI и использует её как единственный источник правды. Ветка с `J0x1D7`, которая мгновенно скрывала окно, теперь недостижима, поэтому окно остаётся включённым по настройке INI. Зацикливания нет, потому что смещение не трогается и управление не прыгает назад.

Почему в декомпиляторе мог появиться «странный» переход
-------------------------------------------------------
Если при замене испортить смещение (`00 D7 01` или обнулить его целиком), дизассемблер строит псевдокод с прыжком на начало функции (`goto J0x00`/`goto J0x400`) и бесконечным циклом. В оригинале ветка уходит строго на `J0x1D7` (см. офсет `D7 01` в строке 61 файла `1.txt`), а после корректного патча с `00 00 00` управление просто движется вниз к чтению `SystemMsgWnd`. Поэтому при проверке убедись, что заменены только первые три байта (`07 D7 01` → `00 00 00`), а байты смещения (`D7 01`) остались нетронутыми.

Соответствие дизассемблированному скрипту `event OnShow()`
----------------------------------------------------------
Фрагмент логики на псевдокоде, как его показывает декомпилятор (см. сниппет ниже), полностью соответствует указанному выше блоку байт:

```
event OnShow()
{
    ...
    goto J0x1D7;
    getInstanceUIData().getIsLiveServer();
    GetINIBool("global", "SystemMsgWnd", m_bUseSystemMsgWnd, "chatfilter.ini");
    if(bool(m_bUseSystemMsgWnd)) { m_hSystemMsgWnd.ShowWindow(); }
    else { m_hSystemMsgWnd.HideWindow(); }
    goto J0x1E6;
    J0x1D7:
    m_hSystemMsgWnd.HideWindow();
    J0x1E6:
    ...
}
```

* Строка `getInstanceUIData().getIsLiveServer();` — это ровно тот вызов, который проверяется командой `JINT` (`07` в HEX). Обнуление трёх байт удаляет проверку целиком, поэтому далее сразу читается `SystemMsgWnd` из INI, и окно остаётся в том состоянии, которое записано в файле настроек.
* Байт-контекст для поиска (`07 D7 01 19 ... 39 16`) берётся прямо из строки `JINT`/`getIsLiveServer()` в `1.txt`, поэтому дополнительный офсет не нужен: HxD найдёт этот участок по уникальной подпоследовательности.

Проверка, что всё сделано корректно
----------------------------------
1. После замены сохраните файл и снова выполните поиск по длинному контексту — совпадение должно остаться в том же месте, но уже с последовательностью `00 00 00` вместо `07 D7 01`.
2. Сравните длину секции: рядом с патчем нет вставок/удалений, поэтому контрольная сумма файла не должна резко измениться.
3. При запуске сценария `OnShow()` окно системных сообщений будет инициализироваться строго по флагу `SystemMsgWnd` в INI, без перехвата `getIsLiveServer()`.
